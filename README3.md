# Алгоритмы и структуры данных

Этот документ содержит описание, определения, пошаговые принципы работы, сложность и примеры результатов основных **алгоритмов сортировки** и **поиска**.

---

## Алгоритмы сортировки

### 1. Сортировка выбором (Selection Sort)

**Определение:**
Сортировка выбором — это алгоритм, который работает путём многократного поиска минимального элемента из неотсортированной части массива и его обмена с первым элементом неотсортированной части.

**Описание:**
На каждом шаге алгоритма находят минимальный элемент среди неотсортированных и меняют его местами с текущим элементом массива.

**Пошаговая работа:**
1. Начинаем с первого элемента массива.
2. Находим минимальный элемент в неотсортированной части.
3. Меняем местами найденный минимальный элемент с текущим.
4. Увеличиваем отсортированную часть на один элемент.
5. Повторяем процесс для оставшейся части массива.

**Сложность:** `O(n²)` во всех случаях.
**Почему:** Алгоритм всегда выполняет два вложенных цикла — внешний проходит по всем элементам, внутренний ищет минимум среди оставшихся.

**Пример:**
- Исходный массив: `[23, 56, 21, 41, 12]`
- Отсортированный массив: `[12, 21, 23, 41, 56]`

---

### 2. Сортировка пузырьком (Bubble Sort)

**Определение:**
Сортировка пузырьком — это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

**Описание:**
Сравниваются соседние элементы и при необходимости меняются местами.

**Пошаговая работа:**
1. Проходим по массиву несколько раз.
2. Сравниваем соседние элементы.
3. Если левый больше правого — меняем их местами.
4. После каждого прохода наибольший элемент всплывает в конец.
5. Повторяем до полной сортировки.

**Сложность:**
- Худший и средний случай: `O(n²)`
- Лучший случай (уже отсортированный массив): `O(n)`

**Почему:** Алгоритм сравнивает все пары соседних элементов. В худшем случае нужно пройти `n` раз по `n` элементам (`O(n²)`), но если массив уже отсортирован — достаточно одного прохода (`O(n)`).

**Пример:**
- Исходный массив: `[64, 34, 25, 12, 22, 11, 90]`
- Отсортированный массив: `[11, 12, 22, 25, 34, 64, 90]`

---

### 3. Сортировка вставками (Insertion Sort)

**Определение:**
Сортировка вставками строит отсортированную часть массива, вставляя каждый новый элемент на правильное место.

**Описание:**
Алгоритм вставляет каждый элемент в нужную позицию в отсортированной части.

**Пошаговая работа:**
1. Начинаем со второго элемента.
2. Запоминаем текущий элемент.
3. Сдвигаем элементы, большие текущего, вправо.
4. Вставляем элемент на найденную позицию.
5. Повторяем для всех элементов.

**Сложность:**
- Худший и средний случай: `O(n²)`
- Лучший случай: `O(n)`

**Почему:** Каждый новый элемент сравнивается со всеми элементами отсортированной части. В худшем случае это `n` сравнений для каждого из `n` элементов (`O(n²)`), а если массив отсортирован — только одно сравнение на элемент (`O(n)`).

**Пример:**
- Исходный массив: `[15, 8, 42, 4, 23, 16]`
- Отсортированный массив: `[4, 8, 15, 16, 23, 42]`

---

### 4. Сортировка слиянием (Merge Sort)

**Определение:**
Алгоритм “разделяй и властвуй”, который рекурсивно делит массив пополам и объединяет отсортированные части.

**Описание:**
Делим массив, сортируем части и объединяем.

**Пошаговая работа:**
1. Разделяем массив пополам.
2. Рекурсивно сортируем левую и правую половины.
3. Объединяем отсортированные половины.

**Сложность:** `O(n log n)` во всех случаях.
**Почему:** Массив делится пополам `log n` раз, а на каждом уровне объединяются `n` элементов.

**Пример:**
- Исходный массив: `[38, 27, 43, 3, 9, 82, 10]`
- Отсортированный массив: `[3, 9, 10, 27, 38, 43, 82]`

---

### 5. Сортировка Шелла (Shell Sort)

**Определение:**
Сортировка Шелла — это усовершенствованная версия сортировки вставками, которая сравнивает элементы на определённом расстоянии.

**Описание:**
Сравнение и перестановка элементов на определённом шаге.

**Пошаговая работа:**
1. Выбираем шаг (`gap = n / 2`).
2. Сортируем элементы с этим шагом методом вставок.
3. Уменьшаем шаг (`gap = gap / 2`).
4. Завершаем сортировку с шагом 1.

**Сложность:**
- В среднем: `O(n log n)`
- В худшем: `O(n²)`

**Почему:** Сортировка вставками выполняется на подмассивах, расстояние между элементами уменьшается с каждым проходом.

**Пример:**
- Исходный массив: `[23, 12, 1, 8, 34, 54, 2, 3]`
- Отсортированный массив: `[1, 2, 3, 8, 12, 23, 34, 54]`

---

### 6. Быстрая сортировка (Quick Sort)

**Определение:**
Алгоритм “разделяй и властвуй”, который выбирает опорный элемент и делит массив на части, меньшие и большие его.

**Описание:**
Делим массив относительно опорного элемента и сортируем рекурсивно.

**Пошаговая работа:**
1. Выбираем опорный элемент.
2. Делим массив на элементы меньше и больше `pivot`.
3. Рекурсивно сортируем обе части.
4. Объединяем результат.

**Сложность:**
- Средний случай: `O(n log n)`
- Худший случай: `O(n²)`

**Почему:** Если опорный элемент делит массив примерно пополам — глубина рекурсии `log n`, а на каждом уровне обрабатываются `n` элементов. Если `pivot` выбирается плохо, сложность возрастает до `O(n²)`.

**Пример:**
- Исходный массив: `[24, 15, 38, 2, 19, 41, 8]`
- Отсортированный массив: `[2, 8, 15, 19, 24, 38, 41]`

---

### 7. Пирамидальная сортировка (Heap Sort)

**Определение:**
Пирамидальная сортировка использует структуру данных “куча” для упорядочивания элементов.

**Описание:**
Строим `max-кучу` и извлекаем элементы по одному.

**Пошаговая работа:**
1. Строим `max-кучу`.
2. Корень кучи содержит максимальный элемент.
3. Меняем корень с последним элементом.
4. Восстанавливаем кучу.
5. Повторяем, пока куча не пуста.

**Сложность:** `O(n log n)` во всех случаях.
**Почему:** Построение кучи выполняется за `O(n)`, а каждая операция извлечения и восстановления кучи требует `O(log n)`.

**Пример:**
- Исходный массив: `[4, 10, 3, 5, 1]`
- Отсортированный массив: `[1, 3, 4, 5, 10]`

---

## Алгоритмы поиска

### 1. Последовательный поиск (Linear Search)

**Определение:**
Последовательный поиск проверяет элементы массива один за другим, пока не найдёт нужный или не дойдёт до конца.

**Пошаговая работа:**
1. Начинаем с первого элемента.
2. Сравниваем каждый элемент с искомым.
3. Если найден — возвращаем индекс.
4. Если дошли до конца — возвращаем `-1`.

**Сложность:** `O(n)`.
**Почему:** В худшем случае алгоритм сравнивает искомый элемент со всеми `n` элементами массива.

**Пример:**
- Массив: `[2, 5, 8, 12, 16, 23, 38, 45]`
- Элемент `16` найден на позиции: `4`

---

### 2. Бинарный поиск (Binary Search)

**Определение:**
Бинарный поиск работает на отсортированном массиве и делит диапазон поиска пополам на каждом шаге.

**Пошаговая работа:**
1. Определяем левую и правую границы.
2. Находим средний элемент.
3. Сравниваем его с искомым.
4. Сужаем диапазон поиска.

**Сложность:** `O(log n)`.
**Почему:** Каждый шаг делит диапазон поиска пополам, что требует `log₂ n` итераций.

**Пример:**
- Массив: `[3, 7, 14, 21, 29, 33, 42, 55, 67, 78]`
- Элемент `29` найден на позиции: `4`
- Элемент `7` найден на позиции: `1`
- Элемент `100` не найден
- Элемент `42` найден на позиции: `6`

---

### 3. Интерполяционный поиск (Interpolation Search)

**Определение:**
Улучшенный бинарный поиск для равномерно распределённых данных.

**Пошаговая работа:**
1. Вычисляем предполагаемую позицию по формуле интерполяции.
2. Сравниваем найденный элемент с искомым.
3. Сужаем область поиска.

**Сложность:**
- Средний случай: `O(log log n)`
- Худший случай: `O(n)`

**Почему:** Если элементы распределены равномерно, позиция быстро уточняется и поиск завершается за `O(log log n)`. При неравномерном распределении может потребоваться проверка всех элементов — `O(n)`.

**Пример:**
- Массив: `[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]`
- Элемент `60` найден на позиции: `5`

---

### 4. Поиск Фибоначчи (Fibonacci Search)

**Определение:**
Алгоритм поиска, использующий числа Фибоначчи для деления массива.

**Пошаговая работа:**
1. Находим число Фибоначчи ≥ длины массива.
2. Определяем позиции для сравнения.
3. Сравниваем элемент в точке разделения с искомым.
4. Сдвигаем область поиска.

**Сложность:** `O(log n)`.
**Почему:** Массив делится не пополам, а по числам Фибоначчи, но количество шагов также пропорционально `log n`.

**Пример:**
- Массив: `[10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]`
- Элемент `85` найден на позиции: `8`
